import sys, glob, os, socket, copy, subprocess, signal
from time import sleep, time
from threading import Lock
# path for file generated by Apache Thrift Compiler
sys.path.append('gen-py')
# add path where built Apache Thrift libraries are
sys.path.insert(0, glob.glob('~/thrift-0.10.0/lib/py/build/lib.*'))

from multiprocessing import Process, Manager

from myfirst import AuthorizationService
from myfirst import MainService
from myfirst.ttypes import *
from myfirst.constants import *

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer


class client:
	def __init__(self, NodeList):
		self.NodeList = NodeList
		self.line_count = 0
		self.main_server_id = -1

	# Sorted nodeList. It's order defines the Synchronizer.
	def addNode(self, node):
		if node not in self.NodeList:
			self.NodeList.append(node)		
			self.NodeList = sorted(self.NodeList, key = lambda Node: int(Node.IPaddress.split(':')[0].split('.')[0]))
			self.NodeList = sorted(self.NodeList, key = lambda Node: int(Node.IPaddress.split(':')[0].split('.')[1]))
			self.NodeList = sorted(self.NodeList, key = lambda Node: int(Node.IPaddress.split(':')[0].split('.')[2]))
			self.NodeList = sorted(self.NodeList, key = lambda Node: int(Node.IPaddress.split(':')[0].split('.')[3]))
			self.NodeList = sorted(self.NodeList, key = lambda Node: int(Node.IPaddress.split(':')[1]))
			print(self.NodeList)

	def removeNode(self, node):
		if node in self.NodeList:
			self.NodeList.remove(node)
			print(self.NodeList)

class MyHandler:

	def __init__(self, cli, usr, messageList, ReceivedMessages, QueueLock, popen):
		self.cli = cli
		self.me = usr
		self.messageList = messageList
		self.ReceivedMessages = ReceivedMessages
		self.QueueLock = QueueLock
		self.pid = popen

	def removeNode(self, node):
		# Removing a Node from the Network
		pass

    # Message from client to the Synchronizer
    # Preserves the same order of messages to all the nodes in the Network by using a Mutex
	def sendMessage(self, Msg):
		if self.cli.NodeList[0].nodeName == self.me.nodeName: # Check if i am the Synchronizer
			# Making sure everyone has the MessageList in correct order in case the Synchronizer crashes ;)
			self.QueueLock.acquire()
			CrashedNode=[]
			for node in self.cli.NodeList: # Then to every Nodes MessageList
				if node.nodeName == self.me.nodeName:
					continue
				try:
					transport = TSocket.TSocket(node.IPaddress.split(':')[0], node.IPaddress.split(':')[1])
					transport = TTransport.TBufferedTransport(transport)
					protocol = TBinaryProtocol.TBinaryProtocol(transport)
					client = MainService.Client(protocol)
					transport.open()
					response = client.AppendToListNode(Msg.IPaddress+"*"+Msg.timeStamp)
					transport.close()
					if response==0:
						CrashedNode.append(node)
				except:
					CrashedNode.append(node)
			if len(CrashedNode) != 0:
				self.recursiveDestruction(CrashedNode[0])
			self.messageList.append(Msg.IPaddress+"*"+Msg.timeStamp) # Put the Msg to Synchronizers MessageList
			self.ReceivedMessages[Msg.IPaddress+"*"+Msg.timeStamp] = Msg.textOfMessage # Put the Message in the Synchronizers dictionary
			self.QueueLock.release()
			return "DO IT"
		else: #Something went wrong. I am not the Synchronizer
			if (Msg.IPaddress+"*"+Msg.timeStamp) not in self.ReceivedMessages.keys():
				self.ReceivedMessages[Msg.IPaddress+"*"+Msg.timeStamp]=Msg.textOfMessage
			return "I am not the Synchronizer, but i got your message."

	# Validating a message to the conversation file
	def ValidateMessage(self, key):
		try:
			textOfMessage = self.ReceivedMessages[key]

			os.system('clear')
			file=open(filename,'a')
			file.write(key.split("*")[0]+" : "+textOfMessage)
			file.write("\n")
			file.close()
			self.cli.line_count +=1

			file=open(filename,'r')
			print(file.read())
			file.close()

			del self.ReceivedMessages[key]
			self.messageList.pop(0)

			return "Validated"
		except KeyError:
			return "There is no such Message"

	# The bridge between the Synchronizer and it's subprocess
	# Messages from the messageList are pushed for Validation to the other Nodes, one by one
	def sendMessageToProcess(self, Key, NotRespondingNodes): 
		Send_Key=""
		if Key in self.ReceivedMessages.keys():

			# First validate the message for yourself
			transport = TSocket.TSocket(self.me.IPaddress.split(':')[0], self.me.IPaddress.split(':')[1])
			transport = TTransport.TBufferedTransport(transport)
			protocol = TBinaryProtocol.TBinaryProtocol(transport)
			client = MainService.Client(protocol)
			transport.open()
			response = client.ValidateMessage(Key)
			transport.close()

			if response != "Validated":
				print("")
				print("Something went wrong while Synchronizer message Validation. Check this!")
				print("Message "+Key)
				print("")

			# Check for Crushed Nodes
			CrushedNodes=[]
			while True:
				try:
					Node = NotRespondingNodes.pop(0)
					try:
						transport = TSocket.TSocket(Node.IPaddress.split(':')[0], Node.IPaddress.split(':')[1])
						transport = TTransport.TBufferedTransport(transport)
						protocol = TBinaryProtocol.TBinaryProtocol(transport)
						client = MainService.Client(protocol)
						transport.open()
						response = client.checkIfNodeIsUp()
					except:
						CrushedNodes.append(Node)
						continue
					if response == "I am up boss!":
						try:
							response=client.refreshYourConversation()
							if response != "I am up to date boss":
								self.recursiveDestruction(Node)
							transport.close()
						except:
							CrushedNodes.append(Node)
							continue
					else:
						print("")
						print("Something went wrong while checking if Node is up. Check it!")
						print("")
						CrushedNodes.append(Node)
					transport.close()
				except IndexError:
					break

			# Removed Crushed Nodes from NodeList
			for Node in CrushedNodes:
				self.recursiveDestruction(Node)

		# Send Message to the subprocess, while removing it
		try:
			Send_Key=self.messageList[0]
		except:
			return Send_Key

		return Send_Key

	def checkIfNodeIsUp(self):
		return "I am up boss!"

	# This is called when a client doen't get a respond from some Node
	# It help removing crushed Nodes from the Network
	def nodeDidNotRespond(self, node):
		if node in self.cli.NodeList:
			try:
				transport = TSocket.TSocket(node.IPaddress.split(':')[0], node.IPaddress.split(':')[1])
				transport = TTransport.TBufferedTransport(transport)
				protocol = TBinaryProtocol.TBinaryProtocol(transport)
				client = MainService.Client(protocol)
				transport.open()
				response = client.checkIfNodeIsUp()
				transport.close()
			except:
				# Send to other nodes this is node is down
				self.recursiveDestruction(node)
				return "Removed"

			if response == "I am up boss!":
				# Check if is upto date
				return "Ready"
		else:
			return "Removed"

    # The Node Refreshes his conversation file
	def refreshYourConversation(self):
		try:
			transport = TSocket.TSocket(self.cli.NodeList[0].IPaddress.split(':')[0], self.cli.NodeList[0].IPaddress.split(':')[1])
			transport = TTransport.TBufferedTransport(transport)
			protocol = TBinaryProtocol.TBinaryProtocol(transport)
			client = MainService.Client(protocol)
			transport.open()
			response = client.updateConversation(self.cli.line_count)
			transport.close()
		except:
			self.recursiveDestruction(self.cli.NodeList[0])
		
		try:
			line_counter += len(temp)
			file=open(filename,'a')
			for line in temp:
				file.write(line)
				
			transport.close()
			file.close()
		except:
			return "Could not update boss"

		return "I am up to date boss"

	# This fancy-ass function recursively removes non-responding Nodes from the Network
	def recursiveDestruction(self, insert_node):
		
		transport = TSocket.TSocket(self.me.IPaddress.split(':')[0], self.me.IPaddress.split(':')[1])
		transport = TTransport.TBufferedTransport(transport)
		protocol = TBinaryProtocol.TBinaryProtocol(transport)
		client = MainService.Client(protocol)
		transport.open()
		response = client.updateNodes(0, insert_node)
		transport.close()

		print(self.cli.NodeList)
		for node in self.cli.NodeList:
			if node == self.me:
				continue
			try:
				transport = TSocket.TSocket(node.IPaddress.split(':')[0], node.IPaddress.split(':')[1])
				transport = TTransport.TBufferedTransport(transport)
				protocol = TBinaryProtocol.TBinaryProtocol(transport)
				client = MainService.Client(protocol)
				transport.open()
				response = client.updateNodes(0, insert_node)
				transport.close()	
			except:
				self.recursiveDestruction(node)
		
		try:
			transport = TSocket.TSocket("localhost", "1337")
			transport = TTransport.TBufferedTransport(transport)
			protocol = TBinaryProtocol.TBinaryProtocol(transport)
			connection = AuthorizationService.Client(protocol)
			transport.open()
			connection.updateNetwork(self.cli.main_server_id, self.cli.NodeList) # Give network list
			transport.close()	
		except:
			print("Could not update main server")

	# this is called when a node wants to enter the Network
	def pingMe(self, Msg):

		# The Synchronizer First Checks if the new Node listens.
		tries=0
		while True:
			sleep(0.1)
			try:
				transport = TSocket.TSocket(Msg.IPaddress.split(':')[0], Msg.IPaddress.split(':')[1])
				transport = TTransport.TBufferedTransport(transport)
				protocol = TBinaryProtocol.TBinaryProtocol(transport)
				client = MainService.Client(protocol)
				transport.open()
				client.checkIfNodeIsUp()
				transport.close()
				break
			except:
				tries+=1
				continue
			if tries>=10:
				break 

		# If the new Node listens the Synchronizer prepares him for the Network
		if tries<10:
			# lock critical area for configuring new Node
			self.QueueLock.acquire() # No new messages can be written while a new Node is entering the Network
			ip, port = Msg.IPaddress.split(':')
			usr = Node()
			usr.IPaddress = ip+":"+port
			usr.nodeName = Msg.textOfMessage

			# The Synchronizer makes sure that all previous messages are written
			while True:
				if len(self.messageList)==0:
					break

			# The Synchronizer sends to everyone the new Node info
			CrashedNode = []
			for node in self.cli.NodeList:
				try:
					transport = TSocket.TSocket(node.IPaddress.split(':')[0], node.IPaddress.split(':')[1])
					transport = TTransport.TBufferedTransport(transport)
					protocol = TBinaryProtocol.TBinaryProtocol(transport)
					client = MainService.Client(protocol)
					transport.open()
					client.updateNodes(1, usr)
					transport.close()
				except:
					CrashedNode.append(node)
			# If someone is down, remove him form the Network
			if len(CrashedNode)>0:
				self.recursiveDestruction(CrashedNode[0])

			# The Synchronizer updates the conversation file of the new Node
			try:
				transport = TSocket.TSocket(usr.IPaddress.split(':')[0], usr.IPaddress.split(':')[1])
				transport = TTransport.TBufferedTransport(transport)
				protocol = TBinaryProtocol.TBinaryProtocol(transport)
				client = MainService.Client(protocol)
				transport.open()
				file=open(filename,'r')
				conversation = str(file.read())
				file.close()
				client.getConversation(conversation)
				client.sendListNodes(self.cli.NodeList)
				transport.close()
			except:
				self.recursiveDestruction(usr)

			# If the new Noe happens to be the next Synchronizer, then the old closes his subprocess and informs the new one to open his
			try:
				if self.cli.NodeList[0].nodeName!=self.me.nodeName:
					transport = TSocket.TSocket(self.cli.NodeList[0].IPaddress.split(':')[0], self.cli.NodeList[0].IPaddress.split(':')[1])
					transport = TTransport.TBufferedTransport(transport)
					protocol = TBinaryProtocol.TBinaryProtocol(transport)
					client = MainService.Client(protocol)
					transport.open()
					client.popen()
					transport.close()
					self.pid.terminate()
					self.pid.kill()
					self.pid = None
			except:
				self.recursiveDestruction(self.cli.NodeList[0])
				print("DONT KNOW WHAT HAPPENS HERE GOD HELP ME")

			# Releasing the Lock. The system is ready for the new messages
			self.QueueLock.release()
			try:
				transport = TSocket.TSocket("localhost", "1337")
				transport = TTransport.TBufferedTransport(transport)
				protocol = TBinaryProtocol.TBinaryProtocol(transport)
				connection = AuthorizationService.Client(protocol)
				transport.open()
				connection.updateNetwork(self.cli.main_server_id, self.cli.NodeList) # Give network list
				transport.close()	
			except:
				print("Could not update main server")

    # Opens the SynchronizationQueue.py subprocess
	def popen(self):
		self.pid = subprocess.Popen([sys.executable, "SynchronizationQueue.py"]+[self.me.IPaddress,self.me.nodeName]) # call subprocess

	# When the previous Synchronizer crushes or exits, this runs in the next Node in the Network hierarchy
	def becomeTheSynchronizer(self):
		# If his list is not empty, it sends the critical message to all other nodes
		if len(self.messageList)!=0:
			# send to everyone the only message that they might have missed
			for Node in self.cli.NodeList:
				try:
					if Node.nodeName == self.me.nodeName:
						continue
					transport = TSocket.TSocket(Node.IPaddress.split(':')[0], Node.IPaddress.split(':')[1])
					transport = TTransport.TBufferedTransport(transport)
					protocol = TBinaryProtocol.TBinaryProtocol(transport)
					client = MainService.Client(protocol)
					transport.open()
					client.getLastMessage(self.ReceivedMessages[self.messageList[-1]])
					transport.close()
				except:
					continue
		# All nodes flush their MessageLists
		for Node in self.cli.NodeList:
			try:
				transport = TSocket.TSocket(Node.IPaddress.split(':')[0], Node.IPaddress.split(':')[1])
				transport = TTransport.TBufferedTransport(transport)
				protocol = TBinaryProtocol.TBinaryProtocol(transport)
				client = MainService.Client(protocol)
				transport.open()
				client.flushYourList()
				transport.close()
			except:
				continue
		# The new Synchronizer starts it's subprocess
		self.pid = subprocess.Popen([sys.executable, "SynchronizationQueue.py"]+[self.me.IPaddress,self.me.nodeName]) # call subprocess	
		
	# The new Synchroniser sends to everyone the last message he received. It's the only one that the other nodes might not have
	def getLastMessage(self, Msg):
		if len(self.messageList)!=0:
			# Checks if it already has the Message. If not it appends it to it's MessageList
			if (self.messageList[-1])!=(self.Msg.IPaddress+"*"+self.Msg.timeStamp):
				self.messageList.append(Msg)
				return 1
			else:
				return 0
		else:
			self.messageList.append(Msg)
			return 1

	# writes all the messages residing in the dictionary in the order indicated by the messageList
	def flushYourList(self):
		if len(self.messageList)!=0:
			# Write all the List to the file
			file=open(filename,'a')
			for key in self.messageList:
				file.write(key.split("*")[0]+" : "+self.ReceivedMessages[key])
				file.write("\n")
				self.cli.line_count +=1
				del self.ReceivedMessages[key]
			file.close()
			self.messageList = []
			return 1
		else:
			return 0

	# Maintaing the order of messages
	def AppendToListNode(self, key):
		try:
			self.messageList.append(key)
			return 1
		except:
			return 0

    # sends the whole converastion 
	def sendConversation(self):
			file=open(filename,'r')
			conversation = str(file.read())
			file.close()
			return conversation

	# sends only the lines of the conversation that the node-server doen't have
	def updateConversation(self, updateLine):
		file=open(filename,'r')
		conversation = file.readlines()[updateLine:]
		file.close()
		return conversation

	def getConversation(self, updateString):
		file=open(filename,'w')
		file.write(updateString)
		file.close()

	def printNodes(self):
		print(self.cli.NodeList)

	def giveNodesInfo(self):
		return self.cli.NodeList

	def sendListNodes(self, NodeList):
		self.cli.NodeList = NodeList
		return 1

	def updateNodes(self, action, node):
		if action == 1:
			self.cli.addNode(node)
		else:
			self.cli.removeNode(node)
			if self.me.nodeName == self.cli.NodeList[0].nodeName and self.pid == None:
				self.QueueLock.acquire()
				if self.pid == None:
					self.becomeTheSynchronizer() # If the Nodes realises that his is the new Synchronizer, he cals this function
				self.QueueLock.release()
		return "Done"

filename="conversation"+sys.argv[1]+".txt"
file=open(filename,'w')
file.close()

usr = Node()
usr.nodeName = sys.argv[2]
 
s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
s.connect(("192.168.1.1",80))

usr.IPaddress=s.getsockname()[0]+":"+sys.argv[1]
QueueLock = Lock()

if sys.argv[3] == "nope":
	cl = client([usr])
	transport = TSocket.TSocket("localhost", "1337")
	transport = TTransport.TBufferedTransport(transport)
	protocol = TBinaryProtocol.TBinaryProtocol(transport)
	connection = AuthorizationService.Client(protocol)
	transport.open()

	main_serv_id=connection.registerNetwork(cl.NodeList) # Give network list
	transport.close()
	cl.main_server_id = main_serv_id
	pid = subprocess.Popen([sys.executable, "SynchronizationQueue.py"]+[usr.IPaddress,usr.nodeName]) # call subprocess
	
else:
	pid = None
	msg = Message()
	msg.textOfMessage = usr.nodeName
	msg.IPaddress = usr.IPaddress
	msg.timeStamp = ""

	ip, port = sys.argv[3].split(':')
	transport = TSocket.TSocket(ip, port)
	transport = TTransport.TBufferedTransport(transport)
	protocol = TBinaryProtocol.TBinaryProtocol(transport)
	connection = MainService.Client(protocol)
	transport.open()

	NodeList=connection.giveNodesInfo() # Give network list
	transport.close()

	ip, port = NodeList[0].IPaddress.split(':')
	transport = TSocket.TSocket(ip, port)
	transport = TTransport.TBufferedTransport(transport)
	protocol = TBinaryProtocol.TBinaryProtocol(transport)
	connection = MainService.Client(protocol)
	transport.open()
	connection.pingMe(msg) # add node-server to the party
	transport.close()
	
	cl = client(NodeList)

handler = MyHandler(cl, usr, [], {}, QueueLock, pid)
processor = MainService.Processor(handler)
transport = TSocket.TServerSocket(port=int(sys.argv[1]))
tfactory = TTransport.TBufferedTransportFactory()
pfactory = TBinaryProtocol.TBinaryProtocolFactory()

server = TServer.TThreadPoolServer(processor, transport, tfactory, pfactory)
	
# start serving
server.serve()
