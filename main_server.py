import hashlib, getpass, sys, glob, os, socket, datetime
# path for file generated by Apache Thrift Compiler
sys.path.append('gen-py')
# add path where built Apache Thrift libraries are
sys.path.insert(0, glob.glob('~/thrift-0.10.0/lib/py/build/lib.*'))

import os.path
from myfirst import AuthorizationService
from myfirst.ttypes import *
from myfirst.constants import *

from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer

# how many minutes to leave user logged in
USER_UPTIME = 10

# method that allows processing the file that has usernames/passwords in
def process_file(file_name):
	
	user_names = []
	passwords = []
	
	try:
		# open file
		file_conn = open(file_name)
		data = file_conn.readlines()

		# usernames are on even number lines and passwords on odd number lines 
		for i in range(len(data)): 
			if i%2 == 0:
				user_names.append(data[i][:-1])
			else:
				passwords.append(data[i][:-1])
			
		file_conn.close()
	except:
		sys.exit('There was a problem reading the file!')
	
	# return the file username and password lists paired on same indexes
	return user_names, passwords

# logged user, mainly used for pairing a user with his login time
class LoggedUser:

	def __init__(self, User):
		self.user = User
		self.timeOfLogin = datetime.datetime.now()

# here starts the handler
class AuthHandler:

	def __init__(self, fileName):
		self.userFile = fileName # the filename that contain usernames and passwords
		self.online_users = [] # list of online users, contains objects of LoggedUser
		self.online_networks = {} # list of online networks

		# method that allow registering a new user
	def registerRequest(self, Username, Password):

		user_name = Username
		# getpass.getpass('Please Enter a Password: ')
		password = hashlib.sha224(Password.encode()).hexdigest() #passwords are saved through their sha224 hash

		# if file does not exist create it and append the username and password
		if not os.path.exists(self.userFile):
			try:
				file_conn = open(self.userFile,'w')
				file_conn.write(user_name + '\n')
				file_conn.write(password + '\n')
				file_conn.close()
			except:
				sys.exit('There was a problem writing to the file!')
			return True
		else: # if file exists
			user_names, passwords = process_file(self.userFile)
			# check if user has already registered
			if user_name not in user_names: # if not registered, append his u/p in the file
				try:
					file_conn = open(self.userFile,'a')
					file_conn.write(user_name + '\n')
					file_conn.write(password + '\n')
					file_conn.close()
				except: 
					sys.exit('There was a problem writing to the file!')
				return True 
			else: # else return false 
				return False
	
	# login request from client
	def loginRequest(self, Username, Password):
		user_names, passwords = process_file(self.userFile)
			
		user = Username

		#check if user has already logged in the last USER_UPTIME minutes
		for i in self.online_users:
			if i.user == user and i.timeOfLogin > datetime.datetime.now()-datetime.timedelta(minutes = USER_UPTIME):
				return False
			elif i.timeOfLogin < datetime.datetime.now() - datetime.timedelta(minutes = USER_UPTIME):
				# remove users that have expired if you find them
				self.online_users.remove(i)
		# if user is not registerd
		if user not in user_names:
			return False
		
		# if password is wrong
		password = hashlib.sha224(Password.encode()).hexdigest()
		if password != passwords[user_names.index(user)]:
			return False
		# if we got here he is valid, log him in and return True
		self.online_users.append(LoggedUser(user))
		return True

	# logout request from client
	def logoutRequest(self, Username):
		#check all online users
		for i in self.online_users:
			if i.user == Username: # if he is in the list log him out
				self.online_users.remove(i)
				return True
			elif i.timeOfLogin < datetime.datetime.now() - datetime.timedelta(minutes = USER_UPTIME):
				# remove users that have expired if you find them
				self.online_users.remove(i)
		return False

	# request from client to get the NodeList for his chosen network
	def giveNodesInfo(self, Username, choice):
		flag = False
		# check if he is online
		for i in self.online_users:
			if i.user == Username and i.timeOfLogin > datetime.datetime.now() - datetime.timedelta(minutes = USER_UPTIME):
				flag = True

		# if he is online return the chosen network, else return empty list
		if flag:
			try:
				return self.online_networks[int(choice)]
			except:
				return []
		else:
			return []

	# return a string that prints all the available networks
	def giveNetworksInfo(self, Username):
		return_string = "" # the string we return after we enrich it with the required information
		flag = False
		# check if user is online
		for i in self.online_users:
			if i.user == Username and i.timeOfLogin > datetime.datetime.now() - datetime.timedelta(minutes = USER_UPTIME):
				flag = True

		# if he is online return the info string, else return empy string
		if flag:
			for i in self.online_networks.keys():
				return_string += str(i) + ": " + self.online_networks[i][0].nodeName + "\n" 
		return return_string

		# node request for network registration
	def registerNetwork(self, nodeList):
		# start from zero and try to find the next int closer to 0 that is not allready registered
		count = 0
		for i in sorted(list(self.online_networks.keys())):
			if count != i:
				break
			count += 1
		self.online_networks[count] = nodeList
		print(self.online_networks)
		return count
		
	# node request from network that allows the node to refresh the NodeList
	def updateNetwork(self, networkID, nodeList):
		try:
			self.online_networks[networkID] = nodeList
			print(self.online_networks)
			return True
		except:
			return False

# create password file 
filename="passwords.userfile"
if not os.path.isfile(filename):
	file=open(filename,'w')
	file.close()

# start server
handler = AuthHandler(filename)
processor = AuthorizationService.Processor(handler)
transport = TSocket.TServerSocket(port=int("1337"))
tfactory = TTransport.TBufferedTransportFactory()
pfactory = TBinaryProtocol.TBinaryProtocolFactory()

server = TServer.TThreadPoolServer(processor, transport, tfactory, pfactory)

server.serve()
